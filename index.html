<!DOCTYPE html>
<meta charset="utf-8">
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
                      tex2jax: {inlineMath: [['$', '$'], ['\\(','\\)']]},
                      TeX: { equationNumbers: {autoNumber: "AMS"} },
                      "HTML-CSS": { showMathMenu: false,
                                    scale: 90 }

                     });
</script>
<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.4.2/pure-min.css">
<style>

@import url(http://fonts.googleapis.com/css?family=PT+Serif|PT+Serif:b|PT+Serif:i|PT+Sans|PT+Sans:b);
@import url(http://fonts.googleapis.com/css?family=Lato);
html {
   min-width: 1040px;
}

body {
   background: #fcfcfa;
   color: #333;
   font-family: "PT Serif", serif;
   /*margin: 0 1em 4em auto;*/
   position: relative;
   width: 960px;
   left: 13em;
}

h1, h2, h3, h4 { font-family: "Lato", "PT Serif", serif; color: #000; text-rendering: optimizeLegibility; }

h1 {
  font-size: 64px;
  line-height: 73px;
  font-weight: 900;
  margin-top: 0.67em;
  margin-right: 0;
  margin-bottom: 0;
  margin-left: 0;
}

h2 {
   margin-top: 2em;
}

subtitle {
   display:block;
   font-family: "PT Serif", serif;
   font-size: 32px;
   font-style: italic;
   font-weight: 100;
}

p {
  line-height: 150%;
  width: 720px;
}

a {
  color: steelblue;
  cursor: auto;
}

a:not(:hover) {
   text-decoration: none;
}

pre {
   border-left: solid 2px #ccc;
   padding-left: 18px;
   margin: 2em 0 2em -20px;
}

aside {
   font-size: small;
   right: 0;
   position: absolute;
   width: 180px;
}

#nav {
        left: 5px;
        font-family: "Lato", serif;
        font-weight: 700;
        list-style: none;
        margin: 0;
        position: fixed;
        top: 10px;
        box-sizing: border-box;
}


#nav li {
        margin-bottom: 0px;
}

#nav a {
        color: #333;
        display: block;
        font-size: 14px;
        border-left: 3px solid #fcfcfa;
        padding: 5px 10px;
        text-decoration: none;
}

#nav a:hover {
   border-left: 3px solid steelblue;
}

#nav .current a {
   border-left: 3px solid steelblue;
}


.node rect {
  cursor: move;
  fill-opacity: .9;
  shape-rendering: crispEdges;
}

.node text {
  pointer-events: none;
  text-shadow: 0 1px 0 #fff;
}

.link {
  stroke-opacity: .2;
}

.link:hover {
  stroke-opacity: .5;
}


</style>
<body>
  <ul id="nav">
    <li class="current"><a href="#intro">Intro</a></li>
    <li><a href="#problem">Problem</a></li>
    <li><a href="#model">Model</a></li>
    <li><a href="#implementation">Implementation</a></li>
    <li><a href="#demo">Live Demo</a></li>
  </ul>
  <div id="container">
    <div class="section" id="intro">
      <h1>Fixed Charge Network Flow</h1>
        <subtitle>with integer programming and Gurobi</subtitle>
    </div>

    <div class="section" id="problem">
      <h2><a href="#problem" name="problem">Problem Description</a></h2>
      Problem description goes here

      <p>
      Fixed Charge Network Flow, which application?
      </p>

    </div>
    <div class="section" id="model">
      <h2><a href="#model" name="model">Mathematical Model</a></h2>

      <p>Model description goes here.</p>

      <p>
      We consider a network $G = (V,E)$ with $n$ nodes and $m$ edges. With each edge $(i,j) \in E$ we associate:
      <ul>
	<li>A flow $x_{ij}$</li>
	<li>A maximum capacity $u_{ij}$</li>
	<li>A cost per unit flow $c_{ij}$</li>
	<li>A fixed charge for using the edge $f_{ij}$</li>
      </ul>
      </p>

      <p>
      Moreover, we associate an indicator variable $y_{ij} \in \{0,1\}$ with each edge. If $y_{ij} = 1$ we charge an amount $f_{ij}$
      to allow flow on the edge. If $y_{ij} = 0$, no flow is allowed on the edge and no charge will be made. Therefore, the total cost
      (which we seek to minimize) is given by
      \[
        \sum_{(i,j) \in E} c_{ij} x_{ij} + \sum_{(i,j) \in E} f_{ij} y_{ij}
      \]
      </p>

      <p>
	Since the maximum flow allowed on an edge is $u_{ij}$ if the edge is open ($y_{ij} = 1$) and $0$ if the edge is closed
	($y_{ij} = 0$) we have the constraint
	\[
	0 \leq x_{ij} \leq u_{ij} y_{ij} \quad \forall (i,j) \in E
	\]
      </p>

      <p> We also have 3 types of nodes. There are regular nodes at which flow is conserved
      \[
      \sum_{(i,j) \in E} x_{ij} - \sum_{(j,i) \in E} x_{ji} = 0
      \]
      i.e. the amount flow entering node $i$ is equal to the amount leaving. There are source or supply nodes
       \[
      \sum_{(i,j) \in E} x_{ij} - \sum_{(j,i) \in E} x_{ji} > 0
      \]
      i.e. the amount of flow leaving node $i$ is larger than the amount entering. Finally, we have sink or demand nodes
       \[
      \sum_{(i,j) \in E} x_{ij} - \sum_{(j,i) \in E} x_{ji} < 0
      \]
      i.e. the amount of flow leaving node $i$ is smaller than the amount leaving. In summary, we have the constraint
       \[
      \sum_{(i,j) \in E} x_{ij} - \sum_{(j,i) \in E} x_{ji} = b_i \quad \text{where} \quad
	    \left\{\begin{array}{ll}
             b_i > 0 & \text{Source node}\\
             b_i = 0 & \text{Regular node}\\
	     b_i < 0 & \text{Sink node}
            \end{array}\right.
      \]
      </p>

      <p> So finally our model becomes
       \[
      \begin{array}{ll}
      \text{minimize} & \sum_{(i,j) \in E} c_{ij} x_{ij} + \sum_{(i,j) \in E} f_{ij} y_{ij} \\
      \text{subject to} & \sum_{(i,j) \in E} x_{ij} - \sum_{(j,i) \in E} x_{ji} = b_i \quad \forall i \in V \\
                        & 0 \leq x_{ij} \leq u_{ij} y_{ij} \quad \forall (i,j) \in E \\
                        & y_{ij} \in \{0,1\}
      \end{array}
      \]
      By solving the optimization problem in the variables $x_{ij}$ and $y_{ij}$ we can compute the optimal flow.
      </p>

    <div class="section" id="implementation">
      <h2><a href="#implementation" name="implementation">Implementation</a></h2>
      <p>Below is the full implementation of the model (and the associated data) in
        Gurobi's Python interface:

      </p>
      <pre>
	from gurobipy import *

	# Vertices and associated source/sink/flow conservation property
	vertices = {0: 4, 1: 3, 2: 2, 3: 0, 4: -6, 5: -3}
	# Capacities and cost. Format is key: edge, value: (capacity, cost per flow, cost to open)
	edges = {(0,4): (4,1,1),
	     (0,3): (2,1,1),
	     (1,3): (3,1,1),
	     (2,5): (2,1,1),
	     (3,4): (2,1,1),
	     (3,5): (1,1,1)}

	m = Model()

	x = {} # Flow on each edge
	y = {} # Binary variable for each edge
	edgeIn   = { v:[] for v in vertices } # Key: vertex, value: set of edges entering vertex
	edgeOut  = { v:[] for v in vertices }

	# Add variables
	for edge in edges:
	    u = edge[0]
	    v = edge[1]
	    y[edge] = m.addVar(vtype=GRB.BINARY, name="y" + str(edge))
	    x[edge] = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name="x" + str(edge) )
	    edgeIn[v] = edgeIn[v] + [x[edge]]
	    edgeOut[u] = edgeOut[u] + [x[edge]]

	m.update()

	# Add constraints
	for v in vertices:
	    m.addConstr(quicksum(edgeOut[v]) - quicksum(edgeIn[v]) == vertices[v], name="v%d" % v)

	for edge in edges:
	    m.addConstr(x[edge] <= edges[edge][0]*y[edge], name=str(edge))

	# Set objective
	m.setObjective(quicksum((edges[edge][1]*x[edge] + edges[edge][2]*y[edge]) for edge in edges), GRB.MINIMIZE)

	m.optimize()
      </pre>
    </div>
    <div class="section" id="demo">
      <h2><a href="#demo" name="demo">Live Demo</a></h2>
      <div id="demoarea">
      </div>
      <button class="pure-button" onclick="compute()">Compute Optimal Flow</button>
    </div>

    <div style="min-height:100px"></div>

<!--[if gt IE 8]><!--><script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script><!--<![endif]-->
<script src="http://davist11.github.io/jQuery-One-Page-Nav/jquery.nav.js"></script>
<script>
  $(document).ready(function() {
  console.log('calling onePageNav');
  $('#nav').onePageNav();
  });
</script>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="sankey.js"></script>
<script>

var units = "Units of flow";

var margin = {top: 10, right: 10, bottom: 10, left: 10},
    width = 700 - margin.left - margin.right,
    height = 300 - margin.top - margin.bottom;

var formatNumber = d3.format(",.0f"),    // zero decimal places
    format = function(d) { return formatNumber(d) + " " + units; },
    color = d3.scale.category20(); // May need to comment this out

// append the svg canvas to the page
var svg = d3.select("#demoarea").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");

// Set the sankey diagram properties
var sankey = d3.sankey()
    .nodeWidth(36)
    .nodePadding(40)
    .size([width, height]);

var path = sankey.link();

// graph data
graph = {
"nodes":[
{"node":0,"name":"Supply0"},
{"node":1,"name":"Supply1"},
{"node":2,"name":"Supply2"},
{"node":3,"name":"Node1"},
{"node":4,"name":"Demand1"},
{"node":5,"name":"Demand2"}
],
"links":[
{"source":0,"target":4,"value":4},
{"source":0,"target":3,"value":0},
{"source":1,"target":3,"value":3},
{"source":2,"target":5,"value":2},
{"source":3,"target":4,"value":2},
{"source":3,"target":5,"value":1}
]};

  sankey
      .nodes(graph.nodes)
      .links(graph.links)
      .layout(32);

// add in the links
  var link = svg.append("g").selectAll(".link")
      .data(graph.links)
    .enter().append("path")
      .attr("class", "link")
      .attr("d", path)
      .style("fill", "none")
      .style("stroke", function (d) {
				      if (d.dy === 0) {
					return "red"; // If no flow is put through, color it red
				      }
				      else {
					return "black";
				      }
				    })
      .style("stroke-width", function(d) { return Math.max(2, d.dy); })
      .sort(function(a, b) { return b.dy - a.dy; });

// add the link titles
  link.append("title")
        .text(function(d) {
    		return d.source.name + " to " +
                d.target.name + "\n" + format(d.value); });

// add in the nodes
  var node = svg.append("g").selectAll(".node")
      .data(graph.nodes)
    .enter().append("g")
      .attr("class", "node")
      .attr("transform", function(d) {
		  return "translate(" + d.x + "," + d.y + ")"; })
    .call(d3.behavior.drag()
      .origin(function(d) { return d; })
      .on("dragstart", function() {
		  this.parentNode.appendChild(this); })
      .on("drag", dragmove));

// add the rectangles for the nodes
  node.append("rect")
      .attr("height", function(d) { return d.dy; })
      .attr("width", sankey.nodeWidth())
      .style("fill", function(d) {
		  console.log('name', d.name);
		  var id = d.name;
		  console.log('id', id);
		  if (id.charAt(0) === "S") { // If it is a supply node, make it green
		    return d.color = "rgb(0," +(Math.min(Math.round(d.dy)*2, 255))+ ", 0)";
		  }
		  else if (id.charAt(0) === "N") { // If it is a normal node, make it blue
		    return d.color = "rgb(0, 0," +(Math.min(Math.round(d.dy)*2, 255))+ ")";
		  }
		  else { // If it is a demand node, make it red
		    return d.color = "rgb(" +(Math.min(Math.round(d.dy)*2, 255))+ ", 0, 0)";
		  }
		  })
      .style("stroke", function(d) {
		  return d3.rgb(d.color).darker(2); })
    .append("title")
      .text(function(d) {
		  return d.name + "\n" + format(d.value); });

// add in the title for the nodes
  node.append("text")
      .attr("x", -6)
      .attr("y", function(d) { return d.dy / 2; })
      .attr("dy", ".35em")
      .attr("text-anchor", "end")
      .attr("transform", null)
      .text(function(d) { return d.name; })
    .filter(function(d) { return d.x < width / 2; })
      .attr("x", 6 + sankey.nodeWidth())
      .attr("text-anchor", "start");

// the function for moving the nodes
  function dragmove(d) {
    d3.select(this).attr("transform",
        "translate(" + d.x + "," + (
                d.y = Math.max(0, Math.min(height - d.dy, d3.event.y))
            ) + ")");
    sankey.relayout();
    link.attr("d", path);
  }

</script>
