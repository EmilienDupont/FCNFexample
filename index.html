<!DOCTYPE html>
<meta charset="utf-8">
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
                      tex2jax: {inlineMath: [['$', '$'], ['\\(','\\)']]},
                      TeX: { equationNumbers: {autoNumber: "AMS"} },
                      "HTML-CSS": { showMathMenu: false,
                                    scale: 90 }

                     });
</script>

<style>

.node rect {
  cursor: move;
  fill-opacity: .9;
  shape-rendering: crispEdges;
}

.node text {
  pointer-events: none;
  text-shadow: 0 1px 0 #fff;
}

.link { 
  stroke-opacity: .2;
}

.link:hover {
  stroke-opacity: .5;
}


</style>
<body>
  <ul id="nav">
    <li class="current"><a href="#intro">Intro</a></li>
    <li><a href="#problem">Problem</a></li>
    <li><a href="#model">Model</a></li>
    <li><a href="#implementation">Implementation</a></li>
    <li><a href="#demo">Live Demo</a></li>
  </ul>
  <div id="container">
    <div class="section" id="intro">
      <h1>Fixed Charge Network Flow</h1>
        <subtitle>with integer programming and Gurobi</subtitle>
    </div>

    <div class="section" id="problem">
      <h2><a href="#problem" name="problem">Problem Description</a></h2>
      Problem description goes here
      
      <p>
      Fixed Charge Network Flow, which application?
      </p>

    </div>
    <div class="section" id="model">
      <h2><a href="#model" name="model">Mathematical Model</a></h2>

      <p>Model description goes here.</p>

      <p> 
      We consider a network $G = (V,E)$ with $n$ nodes and $m$ edges. With each edge $(i,j) \in E$ we associate:
      <ul>
	<li>A flow $x_{ij}$</li>
	<li>A maximum capacity $u_{ij}$</li>
	<li>A cost per unit flow $c_{ij}$</li>
	<li>A fixed charge for using the edge $f_{ij}$</li>
      </ul>
      </p>
      
      <p>
      Moreover, we associate an indicator variable $y_{ij} \in \{0,1\}$ with each edge. If $y_{ij} = 1$ we charge an amount $f_{ij}$
      to allow flow on the edge. If $y_{ij} = 0$, no flow is allowed on the edge and no charge will be made. Therefore, the total cost,
      which we seek to minimize, is given by
      \[
        \sum_{(i,j) \in E} c_{ij} x_{ij} + \sum_{(i,j) \in E} f_{ij} y_{ij}
      \]
      </p>
      
      <p> So finally our model becomes
       \[
      \begin{array}{ll}
      \text{minimize} & \sum_{(i,j) \in E} c_{ij} x_{ij} + \sum_{(i,j) \in E} f_{ij} y_{ij} \\
      \text{subject to} & \sum_{(i,j) \in E} x_{ij} - \sum_{(j,i) \in E} x_{ji} = b_i \quad \forall i \in V \\
                        & 0 \leq x_{ij} \leq u_{ij} y_{ij} \quad \forall (i,j) \in E \\
                        & y_{ij} \in \{0,1\}
      \end{array}
      \]
      By solving the optimization problem in the variables $x_{ij}$ and $y_{ij}$ we can compute the optimal flow.
      </p>
      
    <div class="section" id="implementation">
      <h2><a href="#implementation" name="implementation">Implementation</a></h2>
      <p>Below is the full implementation of the model (and the associated data) in
        Gurobi's Python interface:
      </p>
      <pre>

      </pre>
    </div>
    <div class="section" id="demo">
      <h2><a href="#demo" name="demo">Live Demo</a></h2>
      <div id="demoarea">
      </div>
      <button onclick="compute()">Compute Optimal Flow</button>
    </div>

 
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="sankey.js"></script>
<script>
	
var units = "Units of flow";

var margin = {top: 10, right: 10, bottom: 10, left: 10},
    width = 700 - margin.left - margin.right,
    height = 300 - margin.top - margin.bottom;

var formatNumber = d3.format(",.0f"),    // zero decimal places
    format = function(d) { return formatNumber(d) + " " + units; },
    color = d3.scale.category20(); // May need to comment this out

// append the svg canvas to the page
var svg = d3.select("#demoarea").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", 
          "translate(" + margin.left + "," + margin.top + ")");

// Set the sankey diagram properties
var sankey = d3.sankey()
    .nodeWidth(36)
    .nodePadding(40)
    .size([width, height]);

var path = sankey.link();

// load the data
d3.json("sankey-formatted.json", function(error, graph) {

  sankey
      .nodes(graph.nodes)
      .links(graph.links)
      .layout(32);

// add in the links
  var link = svg.append("g").selectAll(".link")
      .data(graph.links)
    .enter().append("path")
      .attr("class", "link")
      .attr("d", path)
      .style("fill", "none")
      .style("stroke", function (d) {
				      if (d.dy === 0) {
					return "red"; // If no flow is put through, color it red
				      }
				      else {
					return "black";
				      }
				    })
      .style("stroke-width", function(d) { return Math.max(2, d.dy); })
      .sort(function(a, b) { return b.dy - a.dy; });

// add the link titles
  link.append("title")
        .text(function(d) {
    		return d.source.name + " to " + 
                d.target.name + "\n" + format(d.value); });

// add in the nodes
  var node = svg.append("g").selectAll(".node")
      .data(graph.nodes)
    .enter().append("g")
      .attr("class", "node")
      .attr("transform", function(d) { 
		  return "translate(" + d.x + "," + d.y + ")"; })
    .call(d3.behavior.drag()
      .origin(function(d) { return d; })
      .on("dragstart", function() { 
		  this.parentNode.appendChild(this); })
      .on("drag", dragmove));

// add the rectangles for the nodes
  node.append("rect")
      .attr("height", function(d) { return d.dy; })
      .attr("width", sankey.nodeWidth())
      .style("fill", function(d) {
		  console.log('name', d.name);
		  //var id = d.name.charAt(0); // Get first letter of node name
		  var id = d.name;
		  console.log('id', id);
		  if (id.charAt(0) === "S") { // If it is a supply node, make it green
		    return d.color = "rgb(0," +(Math.min(Math.round(d.dy)*2, 255))+ ", 0)";
		  }
		  else if (id.charAt(0) === "N") { // If it is a normal node, make it blue
		    return d.color = "rgb(0, 0," +(Math.min(Math.round(d.dy)*2, 255))+ ")"; 
		  }
		  else { // If it is a demand node, make it red
		    return d.color = "rgb(" +(Math.min(Math.round(d.dy)*2, 255))+ ", 0, 0)";
		  }
		  })
      .style("stroke", function(d) { 
		  return d3.rgb(d.color).darker(2); })
    .append("title")
      .text(function(d) { 
		  return d.name + "\n" + format(d.value); });

// add in the title for the nodes
  node.append("text")
      .attr("x", -6)
      .attr("y", function(d) { return d.dy / 2; })
      .attr("dy", ".35em")
      .attr("text-anchor", "end")
      .attr("transform", null)
      .text(function(d) { return d.name; })
    .filter(function(d) { return d.x < width / 2; })
      .attr("x", 6 + sankey.nodeWidth())
      .attr("text-anchor", "start");

// the function for moving the nodes
  function dragmove(d) {
    d3.select(this).attr("transform", 
        "translate(" + d.x + "," + (
                d.y = Math.max(0, Math.min(height - d.dy, d3.event.y))
            ) + ")");
    sankey.relayout();
    link.attr("d", path);
  }
});

</script>
